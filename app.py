# -*- coding: utf-8 -*-
"""app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1w7ggBiXg80NdUnDIoex61vOMTqA8u2MK
"""

import streamlit as st
import pandas as pd
import numpy as np
import requests
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime
from sklearn.ensemble import IsolationForest, RandomForestRegressor
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score, mean_absolute_error
from sklearn.preprocessing import PolynomialFeatures

st.set_page_config(page_title="Carbon Intensity Analyzer", layout="wide", page_icon="⚡")

# ---------- API Fetch ----------
def fetch_carbon_intensity_data(date):
    url = f'https://api.carbonintensity.org.uk/intensity/date/{date}'
    response = requests.get(url)
    if response.status_code == 200:
        return response.json()['data']
    return []

# ---------- Clean Data ----------
def clean_data(vals):
    vals = [v if v is not None else 0 for v in vals]
    mean_val = np.mean([v for v in vals if v != 0])
    return [v if v != 0 else mean_val for v in vals]

# ---------- Environmental Impact Score ----------
def calculate_environmental_impact_score(intensity):
    if intensity <= 50:
        return np.random.uniform(0, 30)
    elif 51 <= intensity <= 100:
        return np.random.uniform(31, 60)
    else:
        return np.random.uniform(61, 100)

# ---------- Pathway Recommendations ----------
def recommend_pathways(score):
    if score < 30:
        return ["🌞 Increase solar/wind use", "💡 Improve energy efficiency", "🚶‍♂️ Promote sustainable transport"]
    elif score < 60:
        return ["🌳 Carbon offset programs", "🚗 Shift to EVs", "♻️ Waste reduction policies"]
    else:
        return ["📜 Policy advocacy", "🔬 Invest in clean tech", "📢 Awareness campaigns"]

# ---------- UI ----------
st.title("⚡ Carbon Intensity Monitoring & Forecast Dashboard")
tabs = st.tabs(["Live Data", "Prediction", "Anomalies", "Impact Score", "Trend Analysis", "Fuel Factors"])

# ---------- Live Data Tab ----------
with tabs[0]:
    st.subheader("📊 Actual vs Forecast (Live)")
    today = datetime.now().strftime('%Y-%m-%d')
    data = fetch_carbon_intensity_data(today)

    if data:
        times = [datetime.strptime(d['from'], "%Y-%m-%dT%H:%MZ") for d in data]
        actuals = clean_data([d['intensity']['actual'] for d in data])
        forecasts = clean_data([d['intensity']['forecast'] for d in data])

        fig, ax = plt.subplots(figsize=(12, 5))
        ax.plot(times, actuals, label="Actual", color="orange")
        ax.plot(times, forecasts, label="Forecast", color="skyblue")
        ax.fill_between(times, forecasts, color='lightblue', alpha=0.2)
        ax.set_title("Carbon Intensity for Today")
        ax.set_xlabel("Time")
        ax.set_ylabel("gCO2/kWh")
        ax.legend()
        st.pyplot(fig)
    else:
        st.warning("No data available today.")

# ---------- Prediction Tab ----------
with tabs[1]:
    st.subheader("🔮 Next 24h Forecast using Random Forest")
    if data:
        times = [datetime.strptime(d['from'], "%Y-%m-%dT%H:%MZ") for d in data]
        actuals = clean_data([d['intensity']['actual'] for d in data])

        hours = np.array([t.hour for t in times]).reshape(-1, 1)
        minutes = np.array([t.minute for t in times]).reshape(-1, 1)
        X = np.hstack((hours, minutes))
        X_poly = PolynomialFeatures(degree=2).fit_transform(X)

        model = RandomForestRegressor(n_estimators=100)
        model.fit(X_poly, actuals)
        future_times = [times[-1] + pd.Timedelta(hours=i+1) for i in range(24)]
        future_features = PolynomialFeatures(degree=2).fit_transform(
            np.hstack((
                np.array([t.hour for t in future_times]).reshape(-1, 1),
                np.array([t.minute for t in future_times]).reshape(-1, 1)))
        )
        preds = model.predict(future_features)

        fig, ax = plt.subplots(figsize=(12, 5))
        ax.plot(times, actuals, label="Actual", color="orange")
        ax.plot(future_times, preds, label="Prediction (24h)", color="green", linestyle="--")
        ax.set_title("Forecasted Carbon Intensity")
        ax.set_xlabel("Time")
        ax.set_ylabel("gCO2/kWh")
        ax.legend()
        st.pyplot(fig)

# ---------- Anomaly Tab ----------
with tabs[2]:
    st.subheader("🚨 Anomaly Detection with Isolation Forest")
    if data:
        times = [datetime.strptime(d['from'], "%Y-%m-%dT%H:%MZ") for d in data]
        actuals = np.array(clean_data([d['intensity']['actual'] for d in data]))

        X = np.array(range(len(actuals))).reshape(-1, 1)
        iso = IsolationForest(contamination=0.1)
        labels = iso.fit_predict(actuals.reshape(-1, 1))

        fig, ax = plt.subplots(figsize=(12, 5))
        ax.plot(times, actuals, label="Actual", color="orange")
        ax.scatter(np.array(times)[labels == -1], actuals[labels == -1], color="red", label="Anomalies")
        ax.set_title("Detected Anomalies")
        ax.set_xlabel("Time")
        ax.set_ylabel("gCO2/kWh")
        ax.legend()
        st.pyplot(fig)

# ---------- Impact Score Tab ----------
with tabs[3]:
    st.subheader("♻️ Environmental Impact Score")
    if data:
        actuals = clean_data([d['intensity']['actual'] for d in data])
        scores = [calculate_environmental_impact_score(val) for val in actuals]
        df = pd.DataFrame({
            'Time': [d['from'][11:16] for d in data],
            'Actual Intensity': actuals,
            'Impact Score (%)': scores
        })
        st.dataframe(df, use_container_width=True)

        st.markdown("### 💡 Suggested Actions")
        selected_score = st.slider("Select a score to get recommendations", 0, 100, int(scores[-1]))
        recs = recommend_pathways(selected_score)
        for r in recs:
            st.markdown(f"- {r}")

# ---------- Trend Tab ----------
with tabs[4]:
    st.subheader("📈 Trend Analysis")
    monthly_actuals = [48, 50, 54, 57, 58, 62, 67, 81, 98, 112, 121, 118]
    dates = pd.date_range(start='2023-01-01', periods=len(monthly_actuals), freq='M')
    df_trend = pd.DataFrame({'Date': dates, 'Intensity': monthly_actuals})
    df_trend['Rolling Mean'] = df_trend['Intensity'].rolling(3).mean()

    r2 = r2_score(df_trend.dropna()['Intensity'], df_trend.dropna()['Rolling Mean'])
    st.markdown(f"**R² Score for trend fit:** `{r2:.2f}`")

    fig, ax = plt.subplots(figsize=(12, 5))
    sns.lineplot(data=df_trend, x='Date', y='Intensity', label='Actual')
    sns.lineplot(data=df_trend, x='Date', y='Rolling Mean', label='Trend', color='orange')
    ax.set_title("Monthly Carbon Intensity Trend")
    st.pyplot(fig)

# ---------- Fuel Factors Tab ----------
with tabs[5]:
    st.subheader("⚙️ Fuel Factor Breakdown")
    url = "https://api.carbonintensity.org.uk/intensity/factors"
    response = requests.get(url)
    if response.status_code == 200:
        factors = response.json()['data'][0]
        df_fuel = pd.DataFrame({
            'Fuel Source': list(factors.keys()),
            'Contribution (%)': list(factors.values())
        })
        st.dataframe(df_fuel, use_container_width=True)
        fig, ax = plt.subplots()
        ax.pie(df_fuel['Contribution (%)'], labels=df_fuel['Fuel Source'], autopct='%1.1f%%')
        ax.set_title("Fuel Source Contribution")
        st.pyplot(fig)
    else:
        st.warning("Unable to fetch fuel factor data.")